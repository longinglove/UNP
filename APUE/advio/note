io多路复用支持应用同时在多个文件描述符上阻塞，并在其中某个可以读写时收到通知，因此，io多路复用成为应用的关键所在，在设计上遵循以下原则：
1,io多路复用:当任何一个文件描述符io就绪时进行通知
2,都不可用时在有可用的文件描述符之前一直处于睡眠状态
3,唤醒:那个文件描述符可用了?
4,处理所有io就绪的文件描述符,没有阻塞
5,返回第一步重新开始
io多路复用主要有三个方案:select,poll和epoll

#include<sys/select.h>
int select(int n, fd_set *readfds. fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
n为集合中文件描述符的最大值加1
readfds:监视是否有数据可读
writefds:监视是否有某个写操作可以无阻塞完成
exceptfds:监视是否发生异常或者出现带外数据
大多数系统把集合实现成位数组
select调用成功时，返回三个集合中io就绪的文件描述符总数，如果给出了超时设置，返回值可能是０，出错时返回值位-1.

#include<poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
struct pollfd {
	int fd;
	short events;
	short revents;
}
poll系统调用解决了一些select()的不足，select()使用了基于文件描述符的三位掩码的解决方案，效率不高。poll()使用了由nfds个pollfd结构体组成的数组
要监视某个文件描述符是否可读写，需要把events设置成POLLIN|POLLOUT，返回时，会检查revents中是否有相应的标志位，如果设置了POLLIN，文件描述符可非阻塞读；如果设置了POLLOUT，文件描述符可非阻塞写，标志位并不是相互排斥的：可以同事设置，表示可以在该文件描述符上读写，而且都不会阻塞。
poll调用成功时，返回revents变量不为0的所有文件描述符个数；如果没有任何事件发生且未超时，返回０，失败返回-1

poll()和select()区别：
1,poll()不需要用户计算最大文件描述符值加1作为参数传给他
2,poll()对于值很大的文件描述符效率更高，例如，select()监视一个值为900的文件描述符，内核需要检查每个集合中的每个位，一直检查900个位
3,select()文件描述符集合是静态的，需要对大小设置进行权衡：如果很小会限制select()可监视的最大文件描述符值，如果很大效率会很低，当值很大时，大的位掩码操作效率不高，尤其是当无法确定集合是否稀疏集合.对于poll()可以准确创建大小合适的数组，如果只需要监视一项，则仅传递一个结构体
4,对于select()调用，返回时会重新创建文件描述符集，因此每次调用都必须重新初始化。poll()系统调用会把输入(events变量)和输出(revents变量)分离开，支持无需改变数组就可以重新使用
5,select()调用的timeout参数在返回时是未定义的，代码需要支持可移植需要重新对他初始化.

select()优点：
select()可移植性更好，有些unix系统不支持poll()
select()提供了更高的超时精度

存储映射io能将一个磁盘文件映射到存储空间的一个缓冲区上，于是，当从存储区中取数据时，就相当于读文件中的相应字节，与此类似，将数据存入缓冲区，相应字节就自动写入文件，这样就可以在不使用read和write的情况下执行io.
